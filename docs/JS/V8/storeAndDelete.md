# 数据存储和回收

## 栈空间和堆空间

在此之前，我们先想想 JS 是什么类型的语言。在使用之前就需要确认其变量数据类型的称为`静态语言`，相反地，在运行过程中需要检查数据类型的语言称为`动态语言`。同时支持隐式类型转换的语言称为`弱类型语言`，不支持隐式类型转换的语言称为`强类型语言`。

可以推断出，JS 属于弱类型的、动态的语言。意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。意味着可以使用同一个变量保存不同类型的数据。

前面介绍过什么是原始类型，什么是引用类型。接下来我们来看看 JS 的内存结构。

### 内存空间

在 JS 的执行过程中， 主要有三种类型内存空间，分别是`代码空间`、`栈空间`和`堆空间`。

这里的栈空间指的就是调用栈，用于存储执行上下文。

可以知道对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。

**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。**

为什么需要这么划分呢？如果所有数据存放在栈空间中，会影响执行上下文的切换效率，进而影响执行效率。

所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

对于赋值操作，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

## 垃圾回收

垃圾回收有两种策略：手动回收，自动回收。JS 属于自动回收策略。那么是怎么使用垃圾回收器自动进行垃圾回收的？

我们分析一段代码：

```js
function foo(){
    var a = 1
    var b = {name:"jsChen"}
    function showName(){
      var c = 2
      var d = {name:"chenyilong369"}
    }
    showName()
}
foo()
```

当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？

当执行完上面的代码后，调用栈上有一个记录当前执行状态的指针（称为 ESP）。此刻指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。

当执行完 showName 函数后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是`销毁 showName 函数执行上下文`的过程。

很明显，showName 的执行上下文还保存在调用栈中，但是此刻已经成为了无效内存，无法访问，当有新的执行上下文压入栈中时，这块内容会被直接覆盖掉。

上面说明的是栈中的数据回收，要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。

### 代际假说

代际假说有两个特点：

- 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 不死的对象，会活得更久。

下面就简要介绍一下 V8 的垃圾回收机制。

结合代际假说，在 V8 中会把堆分为`新生代`和`老生代`两个区域，`新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。`新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。

同时 V8 也为两个区域实现了各自的垃圾回收器：

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

### 引用计数

引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。

```js
const obj = {a: 10};  // 引用 +1
const obj1 = {a: 10};  // 引用 +1
const obj = {};  // 引用 -1
const obj1 = null;  // 引用为 0

```

当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另外一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。

使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

```js
function problem(){ 
    var objectA = {};
    var objectB = {}; 

    objectA.a = objectB;
    objectB.b = objectA; 
}
```

在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。

### 可能造成内存泄露的情况

1. 对象之间的循环引用 
2. 老版IE（IE8及以前）里面DOM与对象之间的循环引用
3. 全局变量会存在于整个应用生命周期，应用不退出不会回收，使用严格模式可以避免这种情况 
4. 闭包因为自身特性，将函数内部变量暴露到了外部作用域，当其自身执行结束时，所暴露的变量并不会回收 
5. 没有clear的定时器

### 垃圾回收器

对于不同的垃圾回收器，实际上都是遵从共同的执行流程。

**首先标记空间中活动对象和非活动对象。**所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

**然后回收非活动对象所占据的内存。**其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

**最后做内存整理。**在回收内存时，难免导致内存中出现不连续空间，这种空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以需要将内存进行整理。

接下来，我们来看看 V8 的两个垃圾回收器。

#### 副垃圾回收器

通常情况下，大多数小的对象都会被分配到新生区，虽说这个区域不大，但是垃圾回收还是比较频繁的。

新生代中主要使用 Scavenge 算法来处理。

<img :src="$withBase('/storeAndDelete01.png')" alt="storeAndDelete01"/>

Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会放在对象区域，当对象区域快被写满时，就会执行一次垃圾回收。

首先对对象区域中的垃圾做标记；标记完成之后，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，将对象区域和空间区域进行角色翻转即可。这种操作还能让新生代中的这两块区域无限重复使用下去。

这样就可以解释新生区空间小的原因了，空间太大的话会导致复制的时间过长，影响执行效率。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JS 引擎采用了`对象晋升策略`，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 主垃圾回收器

老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。所以不适合使用 Scavenge 算法。

主垃圾回收器是采用`标记 - 清除`的算法进行垃圾回收的。

首先是标记阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

接下来就是垃圾的清除过程。它将标记为垃圾数据的数据直接进行清除。

上面的算法会导致出现内存碎片。于是产生了新的算法，`标记-整理`，清楚数据时不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 全停顿

由于 JS 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JS 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为称为`全停顿`。

可以设想一种这样的情景，当你的代码执行是突然有很多大的对象需要清除，这时会导致 JS 脚本暂停，页面可能会出现明显的卡顿。

对于上述问题，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收和 JS 脚本交替进行，直到标记阶段完成。这个算法称为`增量标记算法`。

## 总结

**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。**

对于垃圾回收机制，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。