# 基础

动态规划应用于子问题重叠的情况：

1. 要去刻画最优解的结构特征；
2. 尝试递归地定义最优解的值（就是我们常说的考虑从 $i-1$ 转移到 $i$ ）；
3. 计算最优解；
4. 利用计算出的信息构造一个最优解。

我们练习一下算法导论的题目。

## 钢条切割

给定一段钢条，和不同长度的价格，问如何切割使得总价格最大。

这道题我们发现，我们可以通过将求解规模为 $n$ 的原问题，化为规模更小的子问题。

当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。 我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。

## 矩阵链乘法

给出 $n$ 个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算？

（认为 $p*q$ 的矩阵与 $q*r$ 的矩阵相乘代价是 $p*q*r$ 。）

我们假设矩阵 $A_i$ 的大小为 $p_{i-1}*p_i$ 。那么我们很容易得出公式：

$$
m[i, j]=\left\{
\begin{aligned}
0 & & i = j \\
min_{i\le k < j}\{m[i, k] + m[k+1, j] + p_{i-1} * p_k * p_j\} & & i < j \\ 
\end{aligned}
\right.
$$


$m[i, j]$ 表示矩阵 $A[i]A[i+1]\cdots A[j]$ 的最少乘法运算次数。

## 原理

相信上面两道题不算很难。我们就上面两道题来总结一下 DP 的原理

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 子问题重叠

子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。

### 重构最优解

存表记录最优分割的位置，就不用重新按照代价来重构。

## 经典问题（来自算法导论）

### 最长公共子序列

求两个序列的最长公共子序列（可以不连续）

设 $dp[i][j]$ 为当第一个序列取到第 $i$ 个元素，第二个序列取到第 $j$ 个元素。

可以得出公式：
$$
dp[i, j] = \left\{
\begin{aligned}
dp[i-1,j-1]+1 & & s_1[i] = s_2[j]\\
max\{dp[i-1,j], dp[i, j-1] \} && s_1[i] \neq s_2[j] \\
\end{aligned}
\right.
$$

### 最优二叉搜索树

给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小。

对于一个搜索树，当搜索的元素在树内时，表示搜索成功。当不在树内时，表示搜索失败，用一个“虚叶子节点”来标示搜索失败的情况，因此需要 $n+1$ 个虚叶子节点 ${d_0<d_1<\cdots<d_n}$，对于应 $d_i$ 的概率序列是$ Q={q_0,q_1,\cdots,q_n}$。其中 $d_0$ 表示搜索元素小于 $k_1$ 的失败结果，$d_n$ 表示搜索元素大于 $k_n$ 的失败情况。$ d_i(0<i<n)$表示搜索节点在 $k_i$ 和 $k_{i+1}$ 之间时的失败情况。

那么可以得到一个公式：
$$
\sum_{i=1}^n p_i + \sum_{i=0}^nq_i = 1
$$
由每个关键字和每个虚拟键被搜索的概率，可以确定在一棵给定的二叉查找树T内一次搜索的期望代价。设一次搜索的实际代价为检查的节点个数，即在T内搜索所发现的节点的深度加上1。所以在T内一次搜索的期望代价为：
$$
E[T] = \sum^n_{i=1}(depth_T(k_i)+1)*p_i+\sum^n_{i=0}(depth_T(d_i)+1)*q_i = 1+\sum^n_{i=1}depth_T(k_i)*p_i + \sum_{i=0}^ndepth_T(d_i)*q_i
$$
很明显，如果一棵最优二叉查找树T有一棵包含关键字 $k_i,\cdots,k_j$ 的子树T'，那么这棵子树T’对于对于关键字 $k_i,\cdots,k_j$ 和虚拟键 $d_{i-1},\cdots,d_j$ 的子问题也必定是最优的。

定义 $e[i,j]$ 为搜索一棵包含关键字 $k_i,\cdots,k_j$ 的最优二叉查找树的期望代价.

定义概率总和为：
$$
w(i,j)=\sum^j_{l=i}p_l + \sum^j_{l=i-1}q_l
$$


