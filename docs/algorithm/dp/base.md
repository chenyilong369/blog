# 基础

动态规划应用于子问题重叠的情况：

1. 要去刻画最优解的结构特征；
2. 尝试递归地定义最优解的值（就是我们常说的考虑从 $i-1$ 转移到 $i$ ）；
3. 计算最优解；
4. 利用计算出的信息构造一个最优解。

我们练习一下算法导论的题目。

## 钢条切割

给定一段钢条，和不同长度的价格，问如何切割使得总价格最大。

这道题我们发现，我们可以通过将求解规模为 $n$ 的原问题，化为规模更小的子问题。

当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。 我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。

## 矩阵链乘法

给出 $n$ 个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算？

（认为 $p*q$ 的矩阵与 $q*r$ 的矩阵相乘代价是 $p*q*r$ 。）

我们假设矩阵 $A_i$ 的大小为 $p_{i-1}*p_i$ 。那么我们很容易得出公式：

$$
m[i, j]=\left\{
\begin{aligned}
& 0 & & i = j \\
& min_{i\le k < j}\{m[i, k] + m[k+1, j] + p_{i-1} * p_k * p_j\} & & i < j \\ 
\end{aligned}
\right.
$$


$m[i, j]$ 表示矩阵 $A[i]A[i+1]\cdots A[j]$ 的最少乘法运算次数。

## 原理

相信上面两道题不算很难。我们就上面两道题来总结一下 DP 的原理

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 子问题重叠

子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。

### 重构最优解

存表记录最优分割的位置，就不用重新按照代价来重构。

## 经典问题（来自算法导论）

### 最长公共子序列

求两个序列的最长公共子序列（可以不连续）

设 $dp[i][j]$ 为当第一个序列取到第 $i$ 个元素，第二个序列取到第 $j$ 个元素。

可以得出公式：
$$
dp[i, j] = \left\{
\begin{aligned}
& dp[i-1,j-1]+1 & & s_1[i] = s_2[j]\\
& max\{dp[i-1,j], dp[i, j-1] \} && s_1[i] \neq s_2[j] \\
\end{aligned}
\right.
$$

### 最优二叉搜索树

给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小。

对于一个搜索树，当搜索的元素在树内时，表示搜索成功。当不在树内时，表示搜索失败，用一个“虚叶子节点”来标示搜索失败的情况，因此需要 $n+1$ 个虚叶子节点 ${d_0<d_1<\cdots<d_n}$，对于应 $d_i$ 的概率序列是$ Q={q_0,q_1,\cdots,q_n}$。其中 $d_0$ 表示搜索元素小于 $k_1$ 的失败结果，$d_n$ 表示搜索元素大于 $k_n$ 的失败情况。$ d_i(0<i<n)$表示搜索节点在 $k_i$ 和 $k_{i+1}$ 之间时的失败情况。

那么可以得到一个公式：
$$
\sum_{i=1}^n p_i + \sum_{i=0}^nq_i = 1
$$
由每个关键字和每个虚拟键被搜索的概率，可以确定在一棵给定的二叉查找树T内一次搜索的期望代价。设一次搜索的实际代价为检查的节点个数，即在T内搜索所发现的节点的深度加上1。所以在T内一次搜索的期望代价为：
$$
E[T] = \sum^n_{i=1}(depth_T(k_i)+1)*p_i+\sum^n_{i=0}(depth_T(d_i)+1)*q_i = 1+\sum^n_{i=1}depth_T(k_i)*p_i + \sum_{i=0}^ndepth_T(d_i)*q_i
$$
很明显，如果一棵最优二叉查找树T有一棵包含关键字 $k_i,\cdots,k_j$ 的子树T'，那么这棵子树T’对于对于关键字 $k_i,\cdots,k_j$ 和虚拟键 $d_{i-1},\cdots,d_j$ 的子问题也必定是最优的。

定义 $e[i,j]$ 为搜索一棵包含关键字 $k_i,\cdots,k_j$ 的最优二叉查找树的期望代价.

定义概率总和为：
$$
w(i,j)=\sum^j_{l=i}p_l + \sum^j_{l=i-1}q_l
$$

假设 $k_r$ 是一棵包含关键字 $k_i, \cdots ,k_j$的最优子树的根，则有：
$$
e[i, j] = p_r + (e[i, r-1] + w(i, r-1)) + (e[r+1][j]+w(r+1,j)) \\
w(i, j) = w(i ,r-1) + p_r + w(r+1, j)
$$
两式结合得到
$$
e[i, j] = e[i, r-1]  + e[r+1, j]+ w(i, j)
$$
最后得到
$$
e[i,j] = \left\{
\begin{aligned}
& q_{i-1} &  j = i-1 \\
& \underset{i \le r \le j}{min}\{e[i, r-1] + e[i, r+1] + w(i, j) \} &  i \le j \\
\end{aligned}
\right.
$$

### 最长不下降子序列

求出给定序列的一个最长的子序列，满足这个序列中的后一个元素不小于前一个元素。

这里只讲 $n\log n$ 的解法。

定义：$a[1\cdots n]$为原始序列，$d[k]$ 表示长度为 $k$ 的不下降子序列末尾元素的最小值，$len$ 表示当前已知的最长子序列的长度。

初始化：$d[1]=a[1], len=1$ （0个元素的时候特判一下）

已知最长的不下降子序列长度为1，末尾元素的最小值为 $a[1]$，那么我们让 $i$ 从2到 $n$ 循环，依次求出前i个元素的最长不下降子序列的长度，循环的时候我们只需要维护好 $d$ 这个数组还有 $len$ 就可以了。

那么怎么维护呢？

**考虑新进来一个元素a[i]：**

- 如果这个元素大于等于 $d[len]$，直接让 $d[len+1]=a[i]$，然后 $len++$。这个很好理解，当前最长的长度变成了 $len+1$，而且 $d$ 数组也添加了一个元素。

- 如果这个元素小于 $d[len]$ 呢？说明它不能接在最后一个后面了。那它该替换掉谁呢。

替换掉数组中**第一个**大于它的。**第一个**意味着前面的都小于等于它。假设第一个大于它的是 $d[j]$，说明 $d[1\cdots j-1]$都小于等于它，那么它完全可以接上 $d[j-1]$ 然后生成一个长度为 $j$ 的不下降子序列，而且这个子序列比当前的d[j]这个子序列**更有潜力（因为这个数比 $d[j]$ 小）**。所以就替换掉它就行了，也就是d[j]=a[i]。

至于怎么找，STL 的 upper_bound 帮你找。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int a[40005];
int d[40005];

int main(){
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    if (n==0){  //0个元素特判一下 
        printf("0\n");
        return 0;
    }
    d[1]=a[1];  //初始化 
    int len=1;
    for (int i=2;i<=n;i++){
        //如果可以接在len后面就接上，如果是最长上升子序列，这里变成> 
        if (a[i]>=d[len]) d[++len]=a[i];  
        else{  //否则就找一个最该替换的替换掉 
            //找到第一个大于它的d的下标，如果是最长上升子序列，这里变成lower_bound 
            int j=upper_bound(d+1,d+len+1,a[i])-d;  
            d[j]=a[i]; 
        }
    }
    printf("%d\n",len);    
    return 0;
}
```

### DAG 中的最长简单路径

给定一个有向无环加权图，求图中的最长路径。

该图中的最长距离为14，即2->4->6->2。

首先我们要对有向无环加权图进行**拓扑排序**。拓扑排序的意思简要来说就是将图中顶点和边排成一个线性序列，对于<vi, vj>，经拓扑排序后一定满足vi在vj的前面。

这里简要介绍一下拓扑排序，首先找出图中入度为0的点加入拓扑排序后的序列，例子中为S，接着将<S, v>中顶点v的入度减一，例子中将点C和A的入度减一，此时顶点C的入度为0，将顶点C放入拓扑排序的序列，将从C出发与C相邻的点的入度减一。重复循环此过程，直到所有点都在拓扑排序后的序列中。

那么就下来就很简单了，直接上公式
$$
dp[i] = max(dp[j] + 1), ((j, i)\in E)
$$


