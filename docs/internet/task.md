# 宏任务与微任务

前面也提到过微任务的诞生，但是这两者有什么区别呢？

## 宏任务

页面中的大部分任务都是在主线程上执行的，为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些**消息队列**中的任务称为宏任务。

消息队列中的任务都是通过事件循环来处理的，那么先看看时间循环机制吧，这也是宏任务执行流程：

- 从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。

宏任务无法满足精度高的任务，假设消息队列中存在比较多的任务未完成，这时用户与页面进行了交互，交互产生的任务会放在消息队列的末尾，需要等待前面的任务执行完毕后他才会执行，这样可能会导致用户的体验不顺畅。

同时宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如监听 DOM 变化的需求。

## 微任务

前面说过构成异步回调的两种方式，这里借宏任务的概念进行一下修改。

- 把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。

- 把异步函数添加到微任务队列中，在当前任务的末尾处执行微任务。

**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

当 JS 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个**微任务队列**。也就是说每个宏任务都关联了一个微任务队列。

产生微任务的方法有使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。



