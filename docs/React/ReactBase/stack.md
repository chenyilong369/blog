# 栈调和

在了解 React 16 Fiber 架构前，先了解一下 React 15 的栈调和算法。

## 调和过程与 Diff 算法

“调和”又译为“协调”，协调过程的官方定义，藏在 React 官网对虚拟 DOM 这一概念的解释中，原文如下：

> Virtual DOM 是一种编程概念。在这个概念里，UI 以一种 想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。

**通过如 ReactDOM 等类库使虚拟 DOM 与“真实的” DOM 同步，这一过程叫作协调（调和）**。

Diff 是调和过程中最具代表性的一环

### Diff 算法思想

Diff 算法其实就是“找不同”的过程。在计算机科学领域，要想找出两个树结构之间的不同, 传统的计算方法是通过循环递归进行树节点的一一对比,  这个过程的算法复杂度是 $O(n^3)$。

React 团队结合设计层面的一些推导，总结了以下规律， 为将 $O(n^3)$ 复杂度转换成 $O(n)$ 复杂度确立了大前提：

- 若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构；
- 处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。
- DOM 节点之间的跨层级操作并不多，同层级操作是主流。

<img :src="$withBase('/react/stack01.png')" alt="stack01"/>

那么我们可以总结出 Diff 算法的一些规律：

- Diff 算法性能突破的关键点在于“分层对比”；

- 类型一致的节点才有继续 Diff 的必要性；

- key 属性的设置，可以帮我们尽可能重用同一层级内的节点。

#### 分层对比

结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比。

如果真的发生了跨层级操作呢？比如移动节点，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。

销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。

#### 减少递归

React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点。

####  重用节点

React 对 key 属性的定义：

> key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。

它试图解决的是同一层级下节点的重用问题。