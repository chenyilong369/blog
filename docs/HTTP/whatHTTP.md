# HTTP基础

先看一下最常见的 HTTP 用法：

- GET表示请求访问服务器的类型，称为方法（method）。
- /index.htm 指明了请求访问的资源对象， 也叫做请求 URI（request-URI）。
- HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。

请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段 和内容实体构成的。

- 在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。
- 200 OK 表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。

- 之后的内容称为资源实体的主体（entity body）。

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代 码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

## **HTTP** 是不保存状态的协议 

HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

## 请求 **URI** 定位资源 

HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。 

如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 * 来代替请求 URI。

##  **HTTP** 方法

### **GET** ：获取资源 

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。

### **POST**：传输实体主体

POST 方法用来传输实体的主体。 

### **PUT**：传输文件 

要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

### **HEAD**：获得报文首部 

用于确认 URI 的有效性及资源更新的日期时间等。

### **DELETE**：删除文件 

DELETE 方法按请求 URI 删除指定的资源。

### **OPTIONS**：询问支持的方法

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

### **TRACE**：追踪路径 

TRACE 方法是让 Web 服务器端将之前的请求通信返回给客户端的方法。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。

但是它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，

### **CONNECT**：要求用隧道协议连接代理

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

## 持久连接

持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。

好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。后面有文章会进行介绍。

## 使用 **Cookie** 进行状态管理

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 **Set-Cookie** 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

HTTP 请求报文和响应报文的内容如下

1. 请求报文（没有 Cookie 信息的状态）

   ![image-20210213232817394](C:\Users\陈怿龙\AppData\Roaming\Typora\typora-user-images\image-20210213232817394.png)

2. 响应报文（服务器端生成 Cookie 信息）

   ![image-20210213232843791](C:\Users\陈怿龙\AppData\Roaming\Typora\typora-user-images\image-20210213232843791.png)

3. 请求报文（自动发送保存着的 **Cookie** 信息） 

   ![image-20210213232912267](C:\Users\陈怿龙\AppData\Roaming\Typora\typora-user-images\image-20210213232912267.png)

## **HTTP** 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。

HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

### 报文主体和实体主体的差异 

- 报文（message） 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
- 实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

## **HTTP** 状态码

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

### **2XX** 成功 

- **200 OK**： 表示从客户端发来的请求在服务器端被正常处理了。 
- **204 No Content**：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
- **206 Partial Content** ：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

### 3XX 重定向 

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

- **301 Moved Permanently** ：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

- **302 Found**：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。

- **303 See Other**：该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

- **304 Not Modified** ：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

- **307 Temporary Redirect** ：临时重定向。该状态码与 302 Found 有着相同的含义。307 会遵照浏览器标准，不会从 POST 变成 GET。

### **4XX** 客户端错误 

4XX 的响应结果表明客户端是发生错误的原因所在

- **400 Bad Request**：该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。

- **401 Unauthorized** ：![image-20210214160303228](C:\Users\陈怿龙\AppData\Roaming\Typora\typora-user-images\image-20210214160303228.png)

  该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。

  当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 

- **403 Forbidden** ：该状态码表明对请求资源的访问被服务器拒绝了。

- **404 Not Found** ：该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 

### **5XX** 服务器错误

- **500 Internal Server Error**：该状态码表明服务器端在执行请求时发生了错误。
- **503 Service Unavailable**：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 浏览器端发起 HTTP 请求流程

### 构建请求

首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。

```
GET /index.html HTTP1.1
```

### 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

- 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果缓存查找失败，就会进入网络请求过程了。

### 准备 IP 地址和端口

HTTP 封装好请求的文本信息后，使用 TCP/IP 将其发到网络上，所以 HTTP 开始工作时，浏览器需要通过 TCP 与服务器建立连接。而 TCP 建立连接第一步就是需要准备 IP 地址和端口号。

浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

拿到 IP 之后，接下来就需要获取端口号了。

### 等待 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

### 建立 TCP 连接

HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。

### 发送 HTTP 请求

一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。