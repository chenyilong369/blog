# 作用域

**作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

也就是说函数作用域在函数定义的时候就决定了，并不是取决于函数在哪里调用，这里要注意和this指向分开。

在 ES6 之前，只有`全局作用域`和`函数作用域`，在 ES6 新增了一个块作用域。

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
- 块作用域是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

``` js
if(1){} // if 块
while(1){} // while 块
function() {} // 函数块
```

如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

## 解决变量提升

之前我们也聊过变量提升，那么它的问题在哪呢？

- **变量容易在不被察觉的情况下被覆盖掉**
- **本应销毁的变量没有被销毁**

为了解决这些问题，ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。

```js
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

可以分析得知：

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
- 通过 let 声明的变量，在编译阶段会被存放到词法环境中。
- 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。

<img :src="$withBase('/scope02.png')" alt="scrope02"/>

第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2

<img :src="$withBase('/scope03.png')" alt="scrope03"/>

其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出。（类似调用栈）

再接下来，当执行到作用域块中的 `console.log(a)`这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

<img :src="$withBase('/scope04.png')" alt="scrope04"/>

那么看下面代码，会输出什么？

```js
let myname= 'jschen'
{
  console.log(myname) 
  let myname= 'js'
}
```

会报错，原因在于在块级作用域中 let 声明的变量会被提升，初始化未被提升，在初始化之前使用变量，会形成一个暂时性死区。

:::tip 扩展

var的创建和初始化被提升，赋值不会被提升。

let, const的创建被提升，初始化和赋值不会被提升。

function的创建、初始化和赋值均会被提升。
:::

## 作用域链

首先看段代码：

```js
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "jsChen"
    bar()
}
var myName = "chenyilong369"
foo()
```

发现最后输出的是`chenyilong369`，为什么不是`jsChen`呢？

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果没找到那么 JavaScript 引擎会继续在 `outer 所指向的执行上下文`中查找。

比如上面代码，bar 函数没有在自己的执行上下文中找到 myName 变量，于是就去他的 outer 所指向的执行上下文中查找，而 bar 函数的上一级执行上下文是`全局执行上下文`，所以输出`chenyilong369`。

**如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。**

但是是 foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

因为在 JavaScript 执行过程中，其作用域链是由`词法作用域`决定的。

## 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

<img :src="$withBase('/scope01.png')" alt="scrope01"/>

知道了定义就可以回答上面的问题了。

根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，**词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

## 闭包

```js
function foo() {
    var myName = "chenyilong369"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("jsChen")
bar.getName()
console.log(bar.getName())
```

从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。

**根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量**，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

产生闭包的核心有两步：**第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。**

在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个`“closure(foo)”`的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

所以当执行到 bar.setName 方法中的myName = "jsChen"这句代码时，JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量。

### 回收闭包

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

### 特性

**闭包有三个特性**：

1. 函数嵌套函数。
2. 函数内部可以引用外部的参数和变量。
3. 参数和变量不会被垃圾回收机制回收。

**闭包的好处**：

1. 希望一个变量长期存储在内存中。
2. 避免全局变量的污染。
3. 私有成员的存在。

**闭包的缺点**：

1. 常驻内存，增加内存使用量。
2. 使用不当会很容易造成内存泄露。

## 总结

我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。也通过作用域链解释了闭包。

